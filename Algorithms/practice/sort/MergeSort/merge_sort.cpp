#include <iostream>
using namespace std;

#define sp ' '
#define nl '\n'

void merge(int list[],int start, int end, int mid);

void mergeSort(int list[], int start, int end)
{
	int mid;

	// Базовый шаг рекурсии
	/* start == end - базовый случай рекурсии.
	   В этом случае текущий вызов mergeSort завершается -> управление передается предыдущему вызову mergeSort, где выполняется следующая инструкция. 
	   Пример: вызов mergeSort(list, 0, 0) -> так как 0 == 0, то управдение передается предыдущему вызову mergeSort(list, 0, 1), 
	   где теперь выполняется следующий после него оператор mergeSort(list,1,1) -> 1 == 1,
	   теперь управление передается опять вызову mergeSort(list, 0, 1), но теперь последней в для этого вызова инструкции merge(list, 0, 1, 0).
	*/
 
	// Алгоритмический смысл
	/*
	Если start >= end -> такой подмассив содержит в лучшем случае 1 элемент -> сортировать надо только один элемент, 
	а любая последовательность из одного элемента уже остортирована -> начинается сборка из 2х одноэлементных массивов одного 2-хэлементтного отсортированного
	*/

	if (start < end){ 
      
		mid=(start+end)/2; // Находим "середину" (индекс q из книги)
		mergeSort(list, start, mid); // Сортируем левый подмассив длиной ceil(n/2)
		mergeSort(list, mid+1, end); // Сортируем правый подмассив длиной floor(n/2)
		merge(list,start,end,mid); // Объедянем в полный массив длиной n
	}
}

void merge(int list[],int start, int end, int mid)
{
	int mergedList[7]; // Массив, который получается слиянием двух подмассивов. После, того как он сфоримрован -> он копируется в исходный массив list 
	int i, j, k; // более привычные названия счетчиков циклов 

	i = start; // счетчик, с помощью которого проходим по левому подмассиву(A[p...q] из книги)
	j = mid + 1; // Счеткик, с поомщью которого проходим по правому подмассиву(A[q+1...r] из книги)
	k = start; // общий счетчик цикла, идет по всему текущему массиву(A[p...r] из книги)

	/*
	Одновременно проходим по правому и левому подмассивам и забираем найменьший из i-го и j-го элементов левого и правого подмассивов 
	в вызодной массив(Аналогия из книги: Берем наименьшую из верхних карт двух входных отсортированных колод и кладем ее в выходную колоду)
	*/
	while (i <= mid && j <= end) { 
		if (list[i] < list[j]) {
			mergedList[k] = list[i];
			k++;
			i++;
		}
		else {
			mergedList[k] = list[j];
			k++;
			j++;
		}
	}
	
    /*
	Случай, когда кончилась вторая стопка(j > end), то есть все элементы второй стопки оказались меньше оставшихся в первой -> 
	Докладываем в выходной массив оставшиеся из первого подмассива начиная с меньшего(тк они в нем уже отсортированы) 
	*/
	while(i <= mid)
	{
		mergedList[k] = list[i];
		k++;
		i++;
	}
    
    /*
	Случай, когда кончилась первая стопка(i > mid). то есть все элементы первой стопки оказались меньше чем оставшиеся во второй -> 
	Докладываем в вызодной массив оставшиеся из второго подмассива, начиная с меньшего(с верха стопки)
	*/
	while (j <= end) {
		mergedList[k] = list[j];
		k++;
		j++;
	}
	
    // Поэлементно копируем вспомогательный массив в исходный -> функция ничего не возвращает, а работает "На месте"
	for (i = start; i < k; i++) {
		list[i] = mergedList[i];
	}
}

int main()
{
	int list[7]={3,19,8,0,48,4,5};

	// Вывод на экран исходного неотсортированного массива
	for (int i = 0; i < 7; i++)
	{
        cout << list[i] << sp;
    }
    cout << nl;

	// Сортировка 
	mergeSort(list, 0, 6);

	// Вывод на экран отсортированного массива 
	for (int i = 0; i < 7; i++)
	{
	   cout<<list[i]<< sp;
	}

    return 0;
}