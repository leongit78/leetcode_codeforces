#include <bits/stdc++.h>
using namespace std;

#define N 5

int A[N];

int main()
{
    for(int i = 0; i < N; ++i)
    {
        scanf("%d", &A[i]);
    }

    int i, key;
    // ПО НЕУБЫВАНИЮ
    for(int j = 1; j < N; ++j)
    {
        key = A[j];
        i = j - 1;

        while(i >= 0 && A[i] > key)
        {
            A[i+1] = A[i];
            i--;
        }
        A[i + 1] = key;
    }

    // ПО НЕВОЗРАСТАНИЮ
    // for(int j = 1; j < N; ++j)
    // {
    //     key = A[j];
    //     i = j - 1;

    //     while (i >= 0 && A[i] < key)
    //     {
    //         A[i+1] = A[i];
    //         i--;
    //     }
    //     A[i+1] = key;
        
    // }

    
    for(int i = 0; i < N; ++i)
    {
        printf("%d ", A[i]);
    }
    return 0;
}
// Изначально становимся на 2-ой элемент
// Далее отходим на шаг назад -> если новый элемент больше, то присваиваем следующему новый, отходим еще назад .. 
// Делаем эти шаги пока не встретим элемент <= key, тогда сразу после него располагаем key
// Это все выполняется для следующего элемента(j+1)

// пример

/*
A[5] = 54 -1 0 2 8

54 -1 0 2 8 - ВХОД  j = 1
54 54 0 2 8 

-1 54 0 2 8         j = 2
-1 54 54 2 8
-1 0 54 2 8

-1 0 54 54 8        j = 3
-1 0 2 54 8

-1 0 2 54 54        j = 4
-1 0 2 8 54 - ВЫХОД
*/


// Примечание 

// На каждой итерации for массив состоит из двух частей:

// 1) A[0 .. j-1] - уже отсортированная часть 
// 2) A[j .. n-1] - часть которую надо отсортировать

// Инварианты цикла

// На каждой итерации цикла for подмассив A[0, j-1] состоит из элементов,
// которые изначально находились в A[0,j-1], но теперь расположенны там в отсортированном виде 

// => на каждой итерации for отсортированные элементы A[0, j-1] изначально принадлежали A[0, j-1]
