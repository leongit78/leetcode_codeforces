1) Если обычное решение слишком долгое(мгого чисел и/или огромные числа) -> Попробовать внедрить вспомогательные "подготовленные" массивы и работать с индексами этих массивов.
Примеры:

- В. Перместите в конец. Создаются 2 вспомогательные массива pmax и psum. psum: на i-ой позиции находится сумма i первых членов исходного массива. pmax: на i-ой позиции находится максимальный элемент среди i первых членов исходного массива.
- B. Геллифиш и Гипсофила. Создается вспомогательный массив s, в котором на i-ой позиции находится остаток от деления 2^i на Mod.
- C. Классное разделение. Создаются два вспомогательных массива: 
        - vector<int> freq(n+1) - содержит на i-ой позиции кол-во вхождений числа i в исходный массив v(n)
        - vector<int> distinct(n) - содежит на i-ой позиции кол-во уникальных элементов в пром-тке [0, ... ,i]

2) Нужно сопоставлять одни значения другим - map<>

Примеры:

- А. Антон и многогранники. Создается map<string,int> для соотношения названий многогранников и кол-во их граней